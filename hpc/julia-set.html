<div class="uk-section uk-section-small">
    <div class="uk-container uk-container-small">
        <p id="fractal-headline" class="uk-text-large"></p>
    </div>
</div>

<div id="julia-viz"></div>



<script type="text/javascript">

let julia_set_imports = `
import base64
from functools import partial
from io import BytesIO

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
`;

let dhp_func = `
def douady_hubbard_polynomial(z, *, c):
    return z ** 2 + c
`;

// How many iterations to perform?
let number_of_iterations = Math.round(2**8);
let headline_msg = `Rendering a Julia set with ${number_of_iterations} iterations.`
document.querySelector("#fractal-headline").innerHTML = headline_msg;

let julia_func = `
def julia_set(*, mapping, min_coord, max_coord, width, height, n_iter = 256, threshold = 2.):

    im, re = np.ogrid[
            min_coord.imag: max_coord.imag: height * 1j,
            min_coord.real: max_coord.real: width * 1j,
            ]

    z = (re + 1j * im).flatten()

    # Indices of unescaped pixels
    live, = np.indices(z.shape)

    iterations = np.empty_like(z, dtype=int)

    for i in range(n_iter):

        z_live = z[live] = mapping(z[live])

        escaped = z_live.real**2 + z_live.imag**2 > threshold**2

        iterations[live[escaped]] = i

        live = live[~escaped]

    iterations[live] = n_iter - 1

    return (n_iter - iterations).reshape((height, width))
`;

let img_ratio = 16 / 9;
let max_plt_w_res = 1920; // max plot width resolution
let max_plt_h_res = 1080; // max plot height resolution
let img_w = window.innerWidth;
let img_h = Math.round(img_w / img_ratio);

let julia_plot = `
fig, ax = plt.subplots()

mapping = partial(douady_hubbard_polynomial, c=complex(-0.7, 0.27015j))

image = julia_set(mapping=mapping, min_coord = complex(-1.5, -1), max_coord = complex(1.5, 1), 
                    n_iter = ${number_of_iterations},
                    width = ${max_plt_w_res},
                    height = ${max_plt_h_res})

# plt.axis('off')
ax.imshow(image, cmap='nipy_spectral', origin='lower')
# plt.imshow(image, cmap='nipy_spectral', origin='lower')

plt.show()
`;


let render_julia = `
btmp = BytesIO()
fig.savefig(btmp, format='png')

# Return decoded data
base64.b64encode(btmp.getvalue()).decode('utf8')
`;


let julia_complete = `
${julia_set_imports}

${dhp_func}

${julia_func}

${julia_plot}
`;


let img_width = window.innerWidth / 2;
let img_height = window.innerHeight / 2;

window.onresize = function() {
    img_width = this.innerWidth / 2;
    img_height = this.innerHeight / 2;
}

// Current packages
function evalAndLoad() {

    let loadedPkgs = Object.keys(pyodide.loadedPackages);

    if (loadedPkgs.includes("numpy") === false) {
        languagePluginLoader.then(() => {
            return pyodide.loadPackage(['numpy', 'matplotlib']);
        });
    }
    
    pyodide.runPython(julia_complete);
    let img_data = pyodide.runPython(render_julia);
    document.querySelector("#julia-viz").innerHTML = `<img src="data:image/png;base64,${img_data}" width="${img_width}" height="${img_height}">`;      
}

evalAndLoad();


</script>
